package com.borysenko.multicrypto.crypto;

import com.borysenko.multicrypto.tools.BigConst;

import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Random;

public class KeyShare {

    /**
     * Secret key value
     */
    private BigInteger secret;

    private BigInteger verifier;

    private BigInteger groupVerifier;

    private BigInteger n;

    private final BigInteger delta;

    /**
     * The secret key value used to sign messages.
     */
    private BigInteger signVal;

    private int id;

    private static SecureRandom random;

    static {
        final byte[] randSeed = new byte[20];
        (new Random()).nextBytes(randSeed);
        random = new SecureRandom(randSeed);
    }

    /**
     * Create a new share
     *
     * @param id     -
     *               the identifier of this share
     * @param secret -
     *               a secret value generated by a Dealer
     * @param n      -
     *               the modulo of the group public key
     * @param delta  -
     *               N! (group size factorial)
     */
    KeyShare(final int id, final BigInteger secret, final BigInteger n,
             final BigInteger delta) {
        this.id = id;
        this.secret = secret;
        this.verifier = null;
        this.n = n;
        this.delta = delta;
        this.signVal = BigConst.FOUR.multiply(delta).multiply(secret);
    }

    public int getId() {
        return id;
    }

    BigInteger getSecret() {
        return secret;
    }

    void setVerifiers(final BigInteger verifier, final BigInteger groupVerifier) {
        this.verifier = verifier;
        this.groupVerifier = groupVerifier;
    }

    public BigInteger getVerifier() {
        return verifier;
    }

    public BigInteger getSignVal() {
        return signVal;
    }

    /**
     * Create a SigShare and a Verifier for byte[] b
     */
    public SigShare sign(final byte[] b) {
        final BigInteger x = (new BigInteger(b)).mod(n);

        final int randBits = n.bitLength() + 3 * BigConst.L1;

        // r \elt (0, 2^L(n)+3*l1)
        final BigInteger r = (new BigInteger(randBits, random));
        final BigInteger vPrime = groupVerifier.modPow(r, n);
        final BigInteger xTilde = x.modPow(BigConst.FOUR.multiply(delta), n);
        final BigInteger xPrime = xTilde.modPow(r, n);

        BigInteger c = null;
        BigInteger z = null;
        // Try to generate C and Z
        try {
            MessageDigest md = MessageDigest.getInstance("SHA");
            md.reset();

            md.update(groupVerifier.mod(n).toByteArray());

            md.update(xTilde.toByteArray());

            md.update(verifier.mod(n).toByteArray());

            md.update(x.modPow(signVal, n).modPow(BigConst.TWO, n).toByteArray());

            md.update(vPrime.toByteArray());

            md.update(xPrime.toByteArray());
            c = new BigInteger(md.digest()).mod(n);
            z = (c.multiply(secret)).add(r);
        } catch (final java.security.NoSuchAlgorithmException e) {
            e.printStackTrace();
        }

        final Verifier ver = new Verifier(z, c, verifier, groupVerifier);

        return new SigShare(this.id, x.modPow(signVal, n), ver);
    }
}
